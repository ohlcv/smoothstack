# 多方协作工作流程文档（优化版 3.0）

## 1. 项目背景与目的

### 1.1 概述
本文档描述了由用户与多个AI助手组成的协作工作流程。该流程设计充分利用各方优势，实现高效、可持续的项目协作模式，同时兼顾技术实现和知识传授。

### 1.2 工作流程目标
- 实现用户与多个AI助手之间的结构化高效协作
- 建立基于各方实际能力的角色分工与任务分配机制
- 解决AI上下文限制问题，确保长期项目连续性
- 创建标准化交流格式，降低沟通成本
- 支持各类型项目需求的灵活适配
- 提供学习型项目实施方法，记录关键学习点

## 2. 角色与职责

### 2.1 角色定义（与AI解耦）

#### 用户角色（项目决策者/学习者/协调者/管理者）

**人设描述**:
- 具有项目目标和基本的技术理解能力
- 作为项目的最终决策者和资源提供者
- 在AI助手的指导下进行学习和技能提升
- 负责在AI助手之间传递信息，促进协作
- 承担项目成果的最终验收和应用责任

**核心职责**:
- 确定项目目标、优先级及进度计划
- 作为AI间通信的"中间件"，传递关键信息
- 提供需求、反馈和验证
- **执行实际操作**（如开发环境搭建、软件安装、部署运行等）
- 管理项目文档和代码仓库
- 参与技术方案讨论并作最终决策
- 在过程中学习相关技术知识

**禁止行为**:
- 不应直接修改AI提供的架构设计
- 不应在未咨询相关AI的情况下做重大技术决策
- 不应跳过记录关键决策和文档化步骤

**工作需求**:
- **准备和管理开发环境**，包括安装依赖、配置服务器等
- 需要清晰表达项目初始需求和目标
- 及时在关键决策点提供反馈和确认
- 验证项目阶段性成果是否符合期望
- 在AI助手指导下参与实际操作以加深理解
- 管理项目的时间和资源约束
- 测试运行代码并及时返回结果

**特点与限制**:
- 作为人类用户，不受上下文限制，但有时间和精力限制
- 可以在AI助手之间传递信息，弥补AI助手间无法直接通信的限制
- 对技术实现细节可能不够专业，需要AI助手的引导和解释
- 可以创建和管理代码库，用于长期存储项目成果
- 在项目中同时作为决策者和学习者，需平衡项目进度和学习深度

#### 架构师角色

**人设描述**:
- 系统设计专家，负责设计总体架构
- 对技术选型和框架有深入了解
- 关注可扩展性、可维护性和系统整体一致性
- 制定技术规范和接口标准

**核心职责**:
- 设计系统总体架构和目录结构
- 定义各组件间接口规范和数据结构
- 生成"指挥提示词"并定期更新，协调开发工作
- 维护高层次的架构文档
- 进行技术选型和决策
- 审查开发实现，确保符合总体架构

**禁止行为**:
- 不应直接编写具体实现代码
- 不应过度设计超出项目需求的功能
- 不应忽略用户实际资源限制和技术能力

**特点与最佳实践**:
- 架构文档应为"只写结构不写实现"以节省上下文空间
- 生成的"指挥提示词"应简洁但包含所有必要信息
- 在设计中应预留接口支持未来功能扩展

#### 开发工程师角色

**人设描述**:
- 代码实现专家，负责具体功能实现
- 专注于代码质量、性能和安全性
- 能够将抽象设计转化为可工作的解决方案

**核心职责**:
- 根据架构设计实现具体功能
- 编写高质量、可维护的代码
- 实现单元测试和功能测试
- 处理技术实现中的问题和挑战
- 提供代码文档和学习点
- 执行代码优化和调试

**禁止行为**:
- 不应擅自修改架构设计
- 不应实现未在需求中明确的功能
- 不应忽略代码质量标准和最佳实践

**特点与最佳实践**:
- 专注于单一模块或功能的实现
- 每次提交应包含完整可运行的代码
- 代码应包含适当的注释和学习点标注
- 遵循项目规定的代码风格和命名约定

#### 项目经理角色

**人设描述**:
- 具备项目管理技能和领域知识
- 善于协调资源和解决冲突
- 关注项目整体进度和风险管理
- 促进各方高效协作

**核心职责**:
- 管理项目整体进度和任务分配
- 跟踪和报告项目状态
- 识别和缓解项目风险
- 协调各方工作，确保项目顺利推进
- 制定项目计划和里程碑
- 维护项目文档和进度报告

**禁止行为**:
- 不应干涉技术细节决策
- 不应越过用户做关键业务决策
- 不应忽视团队成员反馈的问题和风险

**特点与最佳实践**:
- 定期提供项目状态摘要和风险评估
- 维护项目时间线和任务优先级
- 协助解决跨角色的协作问题

### 2.2 AI助手特性与限制

#### Claude特性与限制

**优势**:
- 强大的代码生成和实现能力
- 精通系统架构设计和技术细节处理
- 专注于代码质量、性能和安全性
- 能够提供详细的技术决策解释和学习点
- 擅长将抽象概念转化为可工作的解决方案

**限制**:
- **上下文长度限制严重**: 单个对话窗口上下文容量有限，需要高效利用
- 无法直接访问实时信息和最新技术资讯
- 无法直接进行网络搜索或调用外部API
- 无法实时执行代码或验证实现效果

**多窗口工作机制**:
- 可创建多个专用窗口，每个窗口承担特定角色
- 使用"指挥提示词"在窗口间传递上下文
- 窗口角色一旦确定不应更改，保持职责单一性
- 单个窗口聚焦单一模块，减少上下文负担

**角色适合度**:
- 非常适合担任**架构师**和**开发工程师**角色
- 在代码生成和系统设计方面表现优异
- 可以通过多窗口机制支持复杂项目开发

#### Grok特性与限制

**优势**:
- **联网能力**: 可实时搜索并获取最新技术信息和市场趋势
- **DeepSearch功能**: 能进行深度搜索，获取更专业和详细的领域知识
- **超长上下文处理**: 拥有超长上下文窗口，可以处理和记忆大量信息
- **输入输出灵活**: 支持超长单次输入和回复，可以处理复杂需求描述
- **频繁交互能力**: 可以与用户进行高频率对话而不受限制

**限制**:
- **代码实现能力有限**: 主要提供架构和思路，具体代码实现相对较弱
- **无项目及代码库**: 不能创建长期维护的代码项目
- **长对话管理**: 虽然支持超长上下文，但在项目后期可能出现"顾头不顾尾"的情况

**长对话管理策略**:
- 定期提供项目状态摘要和关键决策记录
- 维护内容索引，便于快速引用过去的讨论
- 使用明确格式标记特别重要的内容
- 定期回顾项目目标和核心约束

**角色适合度**:
- 非常适合担任**项目经理**和**技术顾问**角色
- 在信息收集、技术趋势分析方面表现出色
- 适合进行技术方案评估和用户指导

### 2.3 为什么这样设计角色分工

基于以上各方的特点和限制，协作的角色分工设计原则如下：

1. **互补优势原则**:
   - 使用联网AI（如Grok）的实时信息能力弥补非联网AI的信息获取限制
   - 使用编码强AI（如Claude）的代码能力弥补编码弱AI在技术实现方面的不足
   - 用户作为决策者和协调者，弥补AI助手之间无法直接通信的限制

2. **资源优化原则**:
   - 让代码能力强的AI负责代码密集型任务
   - 让信息获取能力强的AI负责信息密集型和沟通密集型任务
   - 用户负责决策和验证任务，确保项目符合实际需求

3. **限制规避原则**:
   - 通过工作流程和沟通规范，规避各方的技术限制
   - 建立定期摘要和回顾机制，确保长期项目不会丢失关键信息
   - 使用项目文件和代码库作为外部记忆，补充AI助手的上下文限制

4. **学习效率原则**:
   - 由系统化思维强的AI提供学习指导和背景知识
   - 由代码实现强的AI提供具体技术实现和学习点
   - 用户通过实践参与深化理解

## 3. 沟通规范与模板

### 3.1 标准回复格式

每次通信必须使用独立的代码块来针对不同角色发送消息，确保信息传递的精确性和减少混淆。

每个独立代码块必须包含以下部分：
1. **标准回复内容**（固定格式，必须使用代码块）
2. **角色反馈内容**（根据需要和角色调整）

格式重点：
1. **每个角色一个代码块**：不同角色的消息必须分开为独立代码块
2. **需要替换内容**：使用"【】"标记的内容需要替换为实际内容
3. **完整格式强制性**：每个代码块必须遵循完整的标准格式
4. **代码块标记**：必须使用三个反引号(` ` `)来标记代码块的开始和结束

### 3.2 单一角色回复模板

以下是对单一角色发送消息的标准格式：

```
====================
来自【发送者角色】对【接收者角色】的回复
当前时间: YYYYMMDDHHMM
当前任务: 【当前任务内容】
阶段目标: 【当前阶段目标】
任务进度: 【进行中/已完成/讨论中】
引用的文件: 【文件名或"无"】
文件路径：【文件路径或"无"】
提交消息: 【提交描述或"无"】
====================
【发送者角色】的想法: 【具体想法或建议】
====================
任务：
  1.【具体任务1】
  2.【具体任务2】
已完成：
  1.备注：【完成内容】
未完成：
  1.备注：【未完成原因】
想说的话：
  【消息内容或标注"无"】
====================
```

### 3.3 示例：架构师对用户的回复

```
====================
来自【架构师】对【用户】的回复
当前时间: 202503132115
当前任务: 系统架构设计
阶段目标: 完成核心组件定义
任务进度: 进行中
引用的文件: architecture_design.md
文件路径：/docs/design/
提交消息: 初步架构设计文档
====================
【架构师】的想法: 系统需要模块化设计，确保未来可扩展性。
====================
任务：
  1.确认技术栈选择
  2.审核数据模型设计
已完成：
  1.备注：已完成系统架构初稿
未完成：
  1.备注：等待技术栈最终确认
想说的话：
  我已经完成了系统初步架构设计，建议采用Django + SQLite作为初期技术栈，后期可平滑迁移至PostgreSQL。请审核附件中的设计文档，特别关注数据模型部分是否满足业务需求。
====================
```

### 3.4 用户回复模板示例

```
====================
来自【用户】对【架构师】的回复
当前时间: 202503132130
当前任务: 审核系统架构设计
阶段目标: 确认架构设计方向
任务进度: 进行中
引用的文件: architecture_feedback.md
文件路径：/docs/feedback/
提交消息: 架构设计反馈意见
====================
【用户】的想法: 架构设计总体合理，但需要考虑初期用户量较小的情况优化资源占用。
====================
任务：
  1.根据反馈修改架构设计
  2.提供HummingbotClient的示例代码
已完成：
  1.备注：已审核架构文档
未完成：
  1.备注：尚未测试技术方案可行性
想说的话：
  我对架构设计文档已经审核完毕，总体来说设计合理。但有几点建议：1)初期可以简化部分组件，减少资源占用；2)请为Hummingbot集成提供更详细的示例代码；3)我希望系统支持动态调整策略参数，无需重启。请根据这些反馈优化架构设计。
====================
```

### 3.5 用户回复模板预填要求

当AI助手在回复中提供用户回复模板时，应当:
- 预测并预填用户可能的回复内容，而非提供空白模板
- 填充所有字段，包括当前时间、任务内容、想法、对各方的任务与信息等
- 尽可能准确预测用户的下一步动作和想法
- 确保预填内容合理且符合项目当前阶段需求
- 用户可以直接复制粘贴此预填模板并做少量修改即可继续工作流程

错误示例（不要这样做）:
提供空白模板，要求用户自行填写所有内容。

正确示例（请按照此方式）:
预填所有字段，提供合理的预测内容供用户参考和修改。

### 3.6 格式规范强调（特别重要）

**格式正确性是协作成功的基础，请特别注意以下要点：**

1. **代码块必须使用**: 所有标准格式内容**必须**使用三个反引号(```)标记为代码块，这不是可选项而是**必须遵守**的规则
2. **完整性检查**: 始终确保代码块标记完整，有开始必有结束，缺一不可
3. **格式一致性**: 严格遵循规定的格式模板，不得随意调整或简化结构
4. **禁止省略**: 不得省略任何规定的格式部分，即使某些字段暂时没有内容也要保留结构
5. **可复制性**: 确保所有代码块格式便于用户直接复制使用，是协作效率的关键
6. **每个角色独立代码块**: 不同角色的消息必须使用独立的代码块，避免角色混淆

#### 3.6.1 正确与错误格式示例

**错误格式示例（不要这样做）**：
将多个角色的消息放在一个代码块中：

```
====================
来自【项目经理】的回复
当前时间: 202503132140
当前任务: 项目协调
任务进度: 进行中
====================

【项目经理】对【架构师】：
任务：
  1.完成架构设计
  2.审核代码实现

【项目经理】对【开发工程师】：
任务：
  1.实现核心功能
  2.编写单元测试
```

**正确格式示例（请按照此格式）**：
每个角色使用独立的代码块：

```
====================
来自【项目经理】对【架构师】的回复
当前时间: 202503132140
当前任务: 项目协调
阶段目标: 确保架构与实现一致
任务进度: 进行中
引用的文件: 无
文件路径：无
提交消息: 无
====================
【项目经理】的想法: 架构设计需要尽快完成以便开发团队开始实现。
====================
任务：
  1.完成架构设计
  2.审核代码实现
已完成：
  1.备注：已提供初步设计
未完成：
  1.备注：详细设计尚未完成
想说的话：
  请尽快完成架构详细设计，开发团队需要这些信息来开始实现工作。
====================
```

然后是单独的第二个代码块：

```
====================
来自【项目经理】对【开发工程师】的回复
当前时间: 202503132140
当前任务: 项目协调
阶段目标: 开始核心功能实现
任务进度: 进行中
引用的文件: 无
文件路径：无
提交消息: 无
====================
【项目经理】的想法: 开发工作需要等待架构设计完成，但可以先准备环境。
====================
任务：
  1.实现核心功能
  2.编写单元测试
已完成：
  1.备注：无
未完成：
  1.备注：等待架构设计完成
想说的话：
  请先准备开发环境，架构师将很快提供详细设计文档。一旦设计完成，请立即开始实现核心功能并确保编写足够的单元测试。
====================
```

### 3.7 跨上下文恢复策略

#### 3.7.1 跨上下文恢复策略（Claude专用）

当需要在Claude创建新对话窗口时，应采用以下恢复策略：

1. **指挥提示词传递**:
   - 架构师窗口定期生成并更新指挥提示词，包含:
     - 项目架构概要
     - 各组件间接口定义
     - 当前开发阶段和重点
     - 技术规范和编码约定
     - 已完成的功能和待实现的功能
   - 用户将最新的指挥提示词复制到新窗口作为首条消息

2. **专用窗口角色定义**:
   - 每个Claude窗口明确定义其角色(架构师/前端/后端/数据库等)
   - 窗口角色一旦确定不宜更改，保持职责单一性
   - 新窗口第一条消息明确告知Claude其担任的具体角色

3. **项目文件共享**:
   - 用户上传架构师创建的最新架构文档至各开发窗口
   - 项目库中的关键文件共享给相关窗口
   - 开发窗口完成的代码通过项目库共享给其他窗口

4. **分模块上下文管理**:
   - 架构师窗口维护全局视图但只包含结构不含实现细节
   - 开发窗口仅关注自己负责的模块，不需了解全部系统
   - 接口规范作为窗口间通信的桥梁

5. **多窗口协作流程**:
   - 架构师窗口首先设计总体架构和接口规范
   - 开发窗口基于接口规范开发具体功能
   - 架构师定期审查各窗口进度，调整架构设计
   - 用户负责在窗口间传递信息和反馈

6. **窗口恢复失败应对策略**：
   - 如果开发窗口未正确接收指挥提示词，用户应立即停止继续工作
   - 重新上传最新的指挥提示词，并明确指出之前的传递失败
   - 明确告知Claude其角色和职责范围
   - 请求Claude确认已理解项目上下文，必要时提供补充信息

#### 3.7.2 长对话管理策略（Grok专用）

当Grok对话上下文过长时，应采用以下管理策略：

1. **定期提供摘要**:
   - 每完成重要阶段后，Grok提供项目状态摘要
   - 整合关键决策点和设计原则

2. **内容索引维护**:
   - 创建并更新关键讨论主题的索引
   - 便于快速引用过去的决策和讨论

3. **重点突出标记**:
   - 使用明确的格式标记特别重要的内容
   - 确保关键信息不会在长对话中被忽略

4. **周期性回顾**:
   - 定期回顾项目目标和核心约束
   - 确保讨论不偏离主要目标

## 4. 学习型项目支持

### 4.1 学习目标管理
- 在项目开始时明确用户希望学习的关键技术点
- 每个阶段结束时总结已掌握的知识点
- 调整后续内容的技术深度以匹配学习进度
- 记录学习成果和技能提升

### 4.2 知识传递方式
- 联网AI负责提供理论基础和整体概念解释
- 代码能力强的AI负责提供实际操作示例和代码解析
- 用户通过实际参与验证学习成果
- 建立项目知识库，记录重要概念和学习资源，以便用户可以完全掌握项目

### 4.3 学习点记录规范

#### 4.3.1 文件级学习目标

每个源代码文件必须包含文件级学习目标：

```python
"""文件名: user_auth.py

模块功能说明: 实现用户认证功能

学习目标:
1. 掌握JWT认证的工作原理
2. 理解Python中的密码哈希处理
3. 学习安全认证的最佳实践
"""

from jwt import encode
from hashlib import sha256

def generate_token(user_id):
    """生成JWT令牌
    
    学习点:
    - JWT由Header、Payload、Signature三部分组成
    - encode方法自动生成签名，避免手动加密
    """
    payload = {"user_id": user_id}
    return encode(payload, "secret_key", algorithm="HS256")

def hash_password(password):
    """密码哈希处理
    
    学习点:
    - SHA256是一种单向哈希算法，不可逆
    - 实际项目中应使用bcrypt等更安全的库
    """
    return sha256(password.encode()).hexdigest()
```

#### 4.3.2 函数级学习点

关键函数必须包含学习点说明：

```python
def complex_function():
    """函数说明
    
    学习点:
    - 这里演示了如何使用XXX技术
    - 这种实现方式比YYY更高效，因为...
    """
    # 实现代码
    
    # 学习点: 这个算法的时间复杂度是O(n)，因为...
    for item in items:
        # 处理逻辑
```

## 5. 标准操作指南

### 5.1 用户操作指南

#### 5.1.1 基本操作流程

为确保协作顺利进行，用户需要执行以下具体操作:

1. **项目准备阶段**:
   - 创建架构师窗口和项目管理窗口
   - 创建项目文件夹和代码仓库
   - 准备开发环境(按照指导安装必要软件)

2. **窗口管理操作**:
   - **架构师窗口创建**: 向AI明确说明其担任架构师角色
   - **开发窗口创建**: 为每个技术领域创建专用窗口(前端/后端/数据库等)
   - **窗口命名建议**: 在聊天标题中注明窗口角色，如"前端开发-Vue"
   - **窗口恢复操作**: 新窗口首次对话时，复制粘贴最新的"指挥提示词"

3. **文件管理操作**:
   - 将架构师设计的文档上传至开发窗口
   - 将项目管理提供的项目管理文档保存并共享给所有窗口
   - 将开发窗口生成的代码保存到正确的项目文件夹中
   - 定期备份项目文件和对话记录

4. **代码验证操作**:
   - 按AI指导在本地环境中运行代码
   - 记录运行结果并反馈给相应的AI窗口
   - 遇到问题时提供完整的错误信息和环境参数

#### 5.1.2 角色交互配置

在项目开发流程模拟中，根据项目需要可灵活配置AI窗口的角色反馈部分：

1. **角色选择与配置**：
   - 每个AI窗口可根据项目需要选择适当的角色身份
   - 常见角色包括：架构师、前端工程师、后端工程师、数据库工程师、DevOps工程师等
   - 对于小型项目，可合并角色（如全栈工程师）
   - 对于复杂项目，可细分角色（如前端可分为UI设计师和前端开发）

2. **角色交互矩阵**：
   - 架构师 → 所有开发角色：提供设计指导和架构约束
   - 前端工程师 → 后端工程师：请求API接口和数据结构
   - 后端工程师 → 数据库工程师：请求数据模型和存储方案
   - 所有角色 → 项目经理：报告进度和风险
   - 项目经理 → 所有角色：协调资源和调整优先级

3. **角色消息自定义**：
   - 用户可选择在回复模板中保留哪些角色的消息部分
   - 不相关的角色消息部分可省略
   - 可添加项目特有的角色（如安全工程师、测试工程师）
   - 标准格式仍需保持，只调整角色列表

4. **角色沟通语气与风格**：
   - 架构师：战略性、全局视角，关注可扩展性和整体设计
   - 前端工程师：关注用户体验和界面实现细节
   - 后端工程师：关注系统性能、安全性和业务逻辑
   - 数据库工程师：关注数据一致性、效率和存储优化
   - DevOps：关注部署流程、监控和系统稳定性
   - 项目经理：关注进度、资源分配和风险管理

#### 5.1.3 操作提示与注意事项

1. **窗口角色固定**:
   - 一旦确定窗口角色，不要中途更改，以免混淆上下文
   - 如需调整职责，建议创建新窗口而非改变现有窗口角色

2. **信息传递责任**:
   - 用户是AI间唯一的通信桥梁，必须准确完整地传递信息
   - 特别注意传递"指挥提示词"和架构变更决策

3. **文件命名与组织**:
   - 严格按照架构师建议的目录结构和命名规范组织文件
   - 为所有文件添加清晰的版本号和最后修改日期

4. **环境管理**:
   - 按AI建议准备开发和测试环境
   - 记录环境配置过程，便于重现和排错
   - 保存环境依赖清单(如package.json, requirements.txt)

5. **运行验证责任**:
   - AI无法直接运行代码，用户必须负责验证代码功能
   - 提供完整的验证结果反馈，包括成功案例和错误情况

#### 5.1.4 任务管理与执行

##### 5.1.4.1 任务分解原则

- 将大任务分解为小任务，每个任务应具有明确的范围和可交付成果
- 每次对话专注于单一任务，避免一次处理多个任务
- 任务之间的依赖关系应明确记录

##### 5.1.4.2 代码生成规范

- **一次一文件**：一次对话原则上只生成一个完整文件
- **自包含**：生成的代码应尽量自包含，减少外部依赖
- **完整实现**：避免部分实现和TODO注释，确保代码可直接使用
- **异常处理**：包含全面的错误检查和异常处理

##### 5.1.4.3 跨角色协作

- 用户作为信息传递的桥梁，负责在窗口间传递信息
- 架构师定期更新"指挥提示词"，反映最新的项目状态
- 共享代码通过项目仓库或用户转发，不在对话中直接引用其他窗口的内容

##### 5.1.4.4 任务完成检查清单

每个任务完成前应检查以下事项：

1. **完整性**：任务是否完全实现，没有遗漏功能
2. **自包含**：代码是否自包含，不依赖未定义的外部代码
3. **异常处理**：是否包含全面的错误处理
4. **文档化**：是否有必要的注释和文档
5. **一致性**：是否与项目架构和设计保持一致
6. **下一步指导**：是否明确指出用户的下一步行动

#### 5.1.5 窗口间协作流程

##### 5.1.5.1 代码共享流程

当需要在窗口间共享代码时，应遵循以下步骤：

1. 源窗口生成完整代码
2. 用户将代码保存至项目仓库或作为消息传递
3. 目标窗口收到代码后确认理解
4. 源窗口和目标窗口通过用户传递反馈

##### 5.1.5.2 接口协议维护

为确保各组件顺利集成：

1. 架构师定义并维护接口规范文档
2. 所有窗口必须严格遵循接口规范
3. 接口变更必须经过架构师审批
4. 接口变更后立即更新指挥提示词并通知所有相关窗口

##### 5.1.5.3 冲突解决机制

当不同窗口之间出现设计或实现冲突时：

1. 用户向架构师窗口报告冲突
2. 架构师窗口分析冲突并提出解决方案
3. 架构师的决定为最终决定
4. 相关窗口按架构师指示调整实现

## 6. 常见问题解答(FAQ)

### 6.1 项目开始问题

**Q1: 如何决定项目中需要哪些AI窗口角色？**  
A: 根据项目规模和复杂度评估。中小型项目通常需要架构师窗口和1-2个开发窗口(如前端和后端)；大型项目可能需要增加数据库、DevOps等专业窗口。先从核心角色开始，根据进展增加专业窗口。

**Q2: 项目初期应该提供哪些信息给联网AI？**  
A: 尽可能提供完整的项目背景、目标、功能需求、技术限制和资源约束。包括时间预期、预算情况、目标用户群体和项目优先级。信息越完整，提供的建议越准确。

**Q3: 如何准备有效的项目需求文档？**  
A: 需求文档应包含项目目标、用户故事、功能列表、非功能需求(如性能、安全)、技术约束和验收标准。可以先准备简单版本，然后让联网AI协助完善和扩充。

### 6.2 沟通和协作问题

**Q4: 如果AI窗口返回无关内容或角色混淆，怎么办？**  
A: 立即停止对话并重新明确角色。例如："请注意，你的角色是前端工程师，负责UI实现。请基于架构师的设计进行前端开发，而不是讨论后端架构。"然后重新发送指挥提示词，确保AI理解其职责范围。

**Q5: 如何处理AI之间的信息不一致？**  
A: 当发现不一致时，在新消息中明确指出："我注意到架构师建议使用JWT认证，但后端窗口实现了基本认证。请统一使用JWT认证方案。"将最新的正确信息同时传递给所有相关窗口，确保一致性。

**Q6: 长时间项目如何保持上下文连续性？**  
A: 定期保存关键文档和决策记录；使用指挥提示词传递最新状态；创建项目进度日志；为每个重要文件保留版本历史；定期让联网AI总结项目状态并更新全局视图。

### 6.3 技术实现问题

**Q7: 如何处理代码运行失败的情况？**  
A: 复制完整错误日志，包括错误信息、堆栈跟踪和环境信息；向相关开发窗口提供这些信息，并明确说明："代码运行失败，以下是错误信息。请分析问题并提供修复方案。"避免模糊描述如"代码不工作"。

**Q8: AI提出的技术方案超出我的技术能力，怎么办？**  
A: 坦诚告知AI你的技术水平，请求提供更详细的实施指导："这个方案对我来说有些复杂，我的技术背景是X。请提供更详细的实施步骤和可能遇到的问题解决方案。"或请求替代方案："有没有对初学者更友好的替代方案？"

**Q9: 如何确保AI不会生成过于复杂的架构？**  
A: 在初始需求中明确说明技术水平和复杂度限制："请设计一个适合初学者的架构方案，避免过度设计和复杂模式。优先考虑可维护性和直观理解，而非性能优化。"

### 6.4 项目管理问题

**Q10: 项目中期如何调整范围和优先级？**  
A: 准备变更请求文档，包含变更内容、原因和影响评估；向项目经理AI提交进行业务影响分析；向架构师AI窗口提交进行技术影响评估；召开变更评审会议，让三方共同决策；更新项目计划和指挥提示词。

**Q11: 如何处理技术债务累积？**  
A: 定期安排"技术债务日"，专注于代码质量改进；让开发窗口识别代码中的技术债务；让项目经理AI帮助制定技术债务管理策略；在指挥提示词中明确技术债务处理的优先级。

**Q12: 如何评估项目是否按计划进行？**  
A: 定期向项目经理AI提供进度更新，请求进度评估；比对实际完成的功能与计划；让项目经理AI分析延误原因并提供调整建议；使用燃尽图或进度表可视化项目状态。

## 7. 重要工作约定

### 7.1 通信相关约定

1. **沟通效率优先**: 所有通信应保持简洁明了，特别是与上下文限制严重的AI的交互
2. **适配AI特点**: 上下文有限的AI交互应高度聚焦技术内容，上下文丰富的AI交互可更全面详尽
3. **信息分层**: 重要信息置顶，细节后置，确保关键点不被遗漏
4. **上下文管理**: 定期总结关键决策和状态，减轻上下文负担
5. **异步协作**: 设计工作流使AI助手可独立工作，减少等待时间
6. **任务明确化**: 每次交互都明确下一步任务和期望输出
7. **反馈机制**: 建立明确的反馈循环，确保方向正确
8. **代码块使用**: 所有标准格式内容**必须**使用三个反引号(```)标记为代码块，确保格式正确呈现和易于复制
9. **格式检查**: 在发送前检查确保代码块标记完整，开始标记后有内容，结束标记前有内容
10. **换行处理**: 代码块内保持原有格式和换行，不额外添加随意的换行或空格
11. **元描述处理**: 当需要在文档中描述代码块格式本身时，使用转义字符或HTML实体

### 7.2 长度限制处理

1. **上下文限制AI信息精简**: 与上下文有限的AI交互时，保持信息高度精简，避免不必要内容
2. **关键信息优先**: 在受限的交互中，优先传递最关键的信息和指令
3. **分阶段交付**: 大型任务分解为小型子任务，避免单次处理过多内容
4. **代码块完整性**: 当内容需要分割时，确保每个部分的代码块标记(```)完整，即每个部分都有开始和结束标记
5. **中间内容分段**: 当中间自由格式内容过长时，可以分成多个中间内容部分，但每部分前后都应有完整的代码块

### 7.3 文档格式约定（重要）

1. **Markdown格式使用**：所有文档和中间内容**必须**使用Markdown格式提供，便于用户直接复制使用
2. **代码标记使用**：代码示例**必须**使用对应语言的代码块标记，如```python、```sql等
3. **结构化内容**：表格、列表等结构化内容**必须**使用相应的Markdown语法
4. **可复制性原则**：所有提供的内容**必须**考虑用户可以直接复制使用，避免需要手动修改格式
5. **一致性要求**：所有AI助手**必须**遵循相同的格式约定，确保文档外观一致
6. **验证步骤**：在发送前，AI助手**必须**验证所有格式标记是否完整和正确
7. **格式优先级**：格式正确性的优先级高于内容完整性，宁可分多次发送也不破坏格式

### 7.4 格式特别强调事项（最高优先级）

以下格式规则具有最高优先级，**任何情况下都不得违反**：

1. **代码块绝对必要**：标准回复格式和用户回复模板**必须**使用代码块包裹，这是**不可违反**的硬性规定
2. **完整标记**：每个代码块**必须**同时有开始和结束标记(```)，缺一不可
3. **预填模板**：提供给用户的回复模板**必须**预填合理内容，**绝不**提供空白模板
4. **禁止简化**：**不得**简化或省略任何规定的格式结构，即使看起来冗余
5. **格式一致性**：所有AI助手**必须**使用完全相同的格式标准，**不允许**任何变体

### 7.5 跨上下文连续性保障

1. **项目文件库**: 维护关键文件，作为长期记忆
2. **版本控制**: 对关键文档和代码实施版本控制，明确标记版本和变更
3. **决策日志**: 维护单独的决策日志文档，记录所有重要技术和业务决策
4. **状态摘要**: 定期创建项目状态摘要，便于上下文重建
5. **知识转移**: 定期将关键知识转化为文档，避免丢失

### 7.6 工作时间与响应约定

1. **响应时间预期**
   - 对关键问题和阻塞性问题，期望AI助手在2小时内响应
   - 对常规问题和更新，期望AI助手在24小时内响应
   - 用户响应时间可能不固定，AI助手应灵活调整工作节奏

2. **工作模式**
   - 采用异步工作模式，不要求所有参与者同时在线
   - 关键决策点可安排同步会议，确保及时决策
   - AI助手应尽量提供独立可执行的任务包，减少等待依赖

3. **休息与恢复**
   - 项目设置定期"技术债务清理日"，用于代码整理和文档更新
   - 密集工作阶段后安排"回顾与调整日"，确保项目健康发展
   - 长期项目设置阶段性休整期，避免倦怠和技术债务累积

## 8. 指挥提示词与角色交互模板

### 8.1 架构师指挥提示词模板

架构师窗口应定期更新的指挥提示词模板，用于跨窗口沟通:

```
=== 项目指挥提示词 ===
项目名称: [项目名]
版本: [版本号]
更新日期: [YYYY-MM-DD]

== 项目架构概要 ==
[简要描述系统架构和技术栈]

== 核心组件及责任 ==
1. 前端:
   - 技术栈: [技术栈详情]
   - 核心组件: [组件列表]
   - 当前进度: [进度描述]
   - 接口依赖: [依赖的API接口]

2. 后端:
   - 技术栈: [技术栈详情]
   - 核心模块: [模块列表]
   - 当前进度: [进度描述]
   - 提供的API: [API列表]

3. 数据库:
   - 数据库类型: [数据库技术]
   - 核心表结构: [表结构概要]
   - 当前进度: [进度描述]

== 本迭代目标 ==
[描述当前迭代的目标和优先级]

== 技术规范 ==
- 代码风格: [编码规范]
- 命名约定: [命名规则]
- 文档要求: [文档标准]
- 测试要求: [测试标准]

== 接口定义 ==
[关键接口的定义和参数]

== 已知问题 ==
[列出当前已知的技术问题和挑战]

== 项目资源 ==
- 架构文档: [文档位置]
- 代码仓库: [仓库地址]
- 设计资源: [设计资源位置]
```

该指挥提示词应由架构师窗口定期更新，用户负责将其传递给各开发窗口。

## 9. 版本历史

| 版本号 | 更新日期   | 主要变更内容                                      |
| ------ | ---------- | ------------------------------------------------- |
| 4.1.0  | 2025-03-13 | 增强角色与AI解耦，优化格式约定和标准操作指南      |
| 4.0.0  | 2025-03-13 | 根据AI建议全面优化，新增角色交互、FAQ和指挥提示词 |
| 3.3.0  | 2025-03-12 | 优化多窗口角色机制，完善角色反馈模板              |
| 3.2.0  | 2025-02-28 | 完善沟通规范和跨上下文恢复策略                    |
| 3.1.0  | 2025-02-15 | 增加用户操作指南和案例示例                        |
| 3.0.0  | 2025-02-01 | 重构整体文档，引入三方协作模式                    |